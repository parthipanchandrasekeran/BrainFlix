{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.v1 = void 0;\n/* eslint-disable no-bitwise */\n\nconst stringify_1 = require(\"./stringify\");\n\nconst rng_1 = require(\"./rng\"); // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nconst v1 = function (options, buf) {\n  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n  let node = options && options.node ? options.node : _nodeId;\n  let clockseq = options && options.clockseq ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options && options.random ? options.random : options && options.rng ? options.rng() : rng_1.rng();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options && options.msecs ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options && options.nsecs ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options && !options.clockseq) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options && !options.nsecs) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify_1.stringify(b);\n};\n\nexports.v1 = v1;","map":{"version":3,"sources":["/Users/parthipanchandrasekaran/brain-flix-app/client/node_modules/react-native-uuid/src/v1.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-bitwise */\nimport {stringify} from './stringify';\nimport {rng} from './rng';\n\ntype V1Options = {\n  node: number[];\n  clockseq: number;\n  msecs: number;\n  nsecs: number;\n  random: number[];\n  rng: () => number[];\n};\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId: number[];\nlet _clockseq: number;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nexport const v1 = (\n  options?: V1Options,\n  buf?: Uint8Array,\n  offset: number = 0,\n) => {\n  let i = (buf && offset) || 0;\n  const b = buf || new Uint8Array(16);\n\n  let node = options && options.node ? options.node : _nodeId;\n  let clockseq = options && options.clockseq ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes =\n      options && options.random\n        ? options.random\n        : options && options.rng\n        ? options.rng()\n        : rng();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1],\n        seedBytes[2],\n        seedBytes[3],\n        seedBytes[4],\n        seedBytes[5],\n      ];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs: number = options && options.msecs ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs: number = options && options.nsecs ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt: number = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options && !options.clockseq) {\n    clockseq = (clockseq + 1) & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options && !options.nsecs) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = (tl >>> 24) & 0xff;\n  b[i++] = (tl >>> 16) & 0xff;\n  b[i++] = (tl >>> 8) & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;\n  b[i++] = (tmh >>> 8) & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = ((tmh >>> 24) & 0xf) | 0x10; // include version\n  b[i++] = (tmh >>> 16) & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = (clockseq >>> 8) | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || stringify(b);\n};\n"]},"metadata":{},"sourceType":"script"}